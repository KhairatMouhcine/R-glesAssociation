<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <title>Algorithme Apriori ‚Äî Treillis complet des itemsets</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
#association-container {
  background: #0d162a;
  margin-top: 30px;
  padding: 20px;
  border-radius: 12px;
  color: #eaf2ff;
}
#rules-table table {
  width: 100%;
  border-collapse: collapse;
  margin-top: 15px;
}
#rules-table th, #rules-table td {
  border: 1px solid #334;
  padding: 5px 10px;
  text-align: center;
}
#rules-table th {
  background: #1f2d4d;
  color: #ffcc80;
}
#final-summary {
  margin-top: 25px;
  padding: 15px;
  background: #162135;
  border-left: 4px solid #00e676;
  border-radius: 8px;
  color: #eaf2ff;
}
#final-summary h3 {
  color: #00e676;
  margin-bottom: 10px;
}




#apriori-container {
  margin-top: 30px;
  background: #0d162a;
  padding: 20px;
  border-radius: 12px;
  color: #eaf2ff;
}
.support-input {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 15px;
}
#minSupport {
  width: 70px;
  padding: 4px 8px;
  background: #19253f;
  border: 1px solid #335;
  color: #fff;
  border-radius: 6px;
}
#apriori-steps table {
  border-collapse: collapse;
  margin-bottom: 20px;
  width: 100%;
}
#apriori-steps th, #apriori-steps td {
  border: 1px solid #334;
  padding: 4px 8px;
  text-align: center;
}
#apriori-steps th {
  background: #1f2d4d;
  color: #ffcc80;
}
.node.valid circle {
  stroke: #00e676; /* vert */
  stroke-width: 3px;
  filter: drop-shadow(0 0 6px #00e676aa);
}
.node.invalid circle {
  stroke: #ff1744; /* rouge */
  stroke-width: 3px;
  filter: drop-shadow(0 0 6px #ff1744aa);
  opacity: 0.6;
}
.edge.invalid-edge {
  stroke: #ff1744;
  stroke-width: 1.8px;
  opacity: 0.5;
}

.edge {
  stroke: #99a;
  stroke-width: 1px;
  opacity: 0.4;
  transition: all 0.5s ease;
}
.node circle {
  transition: all 0.5s ease;
}

    :root{
      --bg:#0b1020;
      --card:#121a33;
      --ink:#e9eefc;
      --muted:#9fb0ff;
      --accent:#6ae3ff;
      --node:#1f2a52;
      --nodeStroke:#7aa2ff;
      --edge:#6b7bb780;
      --edgeHover:#a8c1ff;
      --lvl0:#ffd166;
      --lvl1:#06d6a0;
      --lvl2:#118ab2;
      --lvl3:#073b4c;
      --lvl4:#90e0ef;
      --lvl5:#48cae4;
      --lvl6:#0077b6;
    }

.edge.selected {
  stroke: #ff9f1c;
  stroke-width: 2.5;
}
.node.selected circle {
  stroke: #ffb703; /* n≈ìud s√©lectionn√© */
  stroke-width: 3px;
  filter: drop-shadow(0 0 6px #ffb703aa);
}

.node.parent circle {
  stroke: #2196f3; /* bleu pour parents */
  stroke-width: 3px;
  filter: drop-shadow(0 0 5px #2196f3aa);
}

.node.child circle {
  stroke: #00e676; /* vert pour enfants */
  stroke-width: 3px;
  filter: drop-shadow(0 0 5px #00e676aa);
}

.edge.parent-edge {
  stroke: #2196f3;
  stroke-width: 2.2;
}

.edge.child-edge {
  stroke: #00e676;
  stroke-width: 2.2;
}
    *{box-sizing:border-box}
    body{
      margin:0; background:linear-gradient(180deg,#0b1020 0%,#0b1228 60%,#0b122e 100%);
      color:var(--ink); font:15px/1.45 system-ui,Segoe UI,Roboto,Arial;
    }
    header{
      padding:18px 22px; position:sticky; top:0; z-index:2; backdrop-filter: blur(6px);
      background:linear-gradient(180deg,#0b1020bb,#0b102000);
      border-bottom:1px solid #223; 
    }
    h1{margin:0 0 8px;font-weight:700;font-size:20px}
    .wrap{
      display:grid; grid-template-columns: 360px 1fr; gap:16px; padding:18px 18px 22px;
    }
    .panel{
      background:var(--card); border:1px solid #22345a; border-radius:14px; padding:14px;
      box-shadow: 0 6px 26px #00000055, inset 0 1px 0 #ffffff10;
    }
    .panel h2{margin:0 0 10px;font-size:16px;color:#cfe1ff}
    textarea{
      width:100%; min-height:160px; border-radius:10px; border:1px solid #31406d;
      background:#0f1735; color:var(--ink); padding:10px; resize:vertical; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }
    .row{display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap}
    button{
      appearance:none; border:none; background:linear-gradient(180deg,#2a3a74,#203060);
      color:#eaf2ff; padding:10px 14px; border-radius:12px; font-weight:600; cursor:pointer;
      box-shadow: 0 6px 18px #0008, inset 0 1px 0 #ffffff1a;
    }
    button:hover{filter:brightness(1.08)}
    .hint{color:#9fb0ff; font-size:13px; margin-top:8px}
    .tags{display:flex; gap:6px; flex-wrap:wrap; margin-top:8px}
    .tag{
      background:#0f1735; border:1px solid #334777; color:#cfe1ff;
      border-radius:999px; padding:6px 10px; font:12px ui-monospace, monospace;
    }
    /* SVG area */
    .stage{
      position:relative; overflow:hidden; background:
        radial-gradient(1200px 600px at 50% -20%, #1a235a22, transparent 70%),
        radial-gradient(800px 400px at -10% 110%, #1a235a22, transparent 70%),
        radial-gradient(800px 400px at 110% 110%, #1a235a22, transparent 70%);
      border:1px solid #22345a; border-radius:14px; min-height:520px;
    }
    svg{width:100%; height:900px; display:block}
    .edge{stroke:var(--edge); stroke-width:1.5; fill:none}
    .edge.hover{stroke:var(--edgeHover); stroke-width:2}
    .node{cursor:pointer; transition: transform .1s ease;}
    .node circle{
      fill:var(--node); stroke:var(--nodeStroke); stroke-width:1.5;
      filter: drop-shadow(0 2px 2px #0006);
    }
    .node text{
  fill:#eaf2ff;
  font-size:15px;
  font-weight:600;
  font-family:ui-monospace, monospace;
  dominant-baseline:middle;
  text-anchor:middle;
  pointer-events:none; /* emp√™che le texte de bloquer le survol */
}
    .lvl-0 circle{fill:var(--lvl0)}
    .lvl-1 circle{fill:var(--lvl1)}
    .lvl-2 circle{fill:var(--lvl2)}
    .lvl-3 circle{fill:var(--lvl3)}
    .lvl-4 circle{fill:var(--lvl4)}
    .lvl-5 circle{fill:var(--lvl5)}
    .lvl-6 circle{fill:var(--lvl6)}
    .legend{display:flex; gap:8px; flex-wrap:wrap; margin-top:10px}
    .legend .sw{width:12px;height:12px;border-radius:50%}
    .legend .it{display:flex;align-items:center;gap:6px;font-size:12px;color:#cfe1ff}
    .sep{height:1px;background:#22345a;margin:10px 0}
    .small{font-size:12px;color:#b9c7ff}
  </style>
</head>
<body>
  <header>
    <h1>Algorithme Apriori ‚Äî Treillis complet des itemsets</h1>
    <div class="small">√âtape 1/2 : arbre complet (zoomable). √âtape 2 : min_support et niveaux L<sub>k</sub>/C<sub>k</sub>.</div>
  </header>

  <div class="wrap">
    <section class="panel">
      <h2>Dataset (base D)</h2>
      <textarea id="dataset" spellcheck="false">100: 1 3 4
200: 2 3 5
300: 1 2 3 5
400: 2 5</textarea>

      <div class="row">
        <button id="btnBuild">G√©n√©rer l‚Äôarbre</button>
        <button id="btnSample">Exemple 1..5</button>
      </div>

      <div class="hint">Format : <code>TID: items s√©par√©s par des espaces</code>.</div>

      <div class="sep"></div>
      <h2>Items d√©tect√©s</h2>
      <div id="items" class="tags"></div>

      <div class="sep"></div>
      <div class="legend" id="legend"></div>
    </section>

    <section class="panel stage">
      <svg id="svg" viewBox="0 0 1400 900" preserveAspectRatio="xMidYMid meet"></svg>
    </section>
  </div>


<!-- 2eme partie -->
 
<div id="apriori-container" class="panel">
  <h3>üîç Calcul du support ‚Äî Algorithme Apriori</h3>
  <div class="support-input">
    <label for="minSupport">min_support = </label>
    <input type="number" id="minSupport" min="1" value="2" />
    <button id="btnSupport">Calculer les niveaux L<sub>k</sub></button>
  </div>
  <div id="apriori-steps"></div>
</div>

<!-- 3eme partie -->
<div id="association-container" class="panel">
  <h3>üß† R√®gles d‚Äôassociation</h3>
  <div id="rules-summary"></div>
  <div id="rules-table"></div>
</div>

<button id="btnRules">G√©n√©rer les r√®gles</button>
  

<script>


    document.getElementById('btnRules')?.addEventListener('click', calculerRegles);
  const uniq = arr => [...new Set(arr)];
  // üîÅ au lieu de byNum:
const bySym = (a, b) => {
  const na = Number(a), nb = Number(b);
  const aIsNum = !Number.isNaN(na), bIsNum = !Number.isNaN(nb);
  if (aIsNum && bIsNum) return na - nb;           // 1,2,3...
  return String(a).localeCompare(String(b), 'fr'); // A,B,C...
};

// üîÅ remplace parseDataset par :
function parseDataset(text){
  const lines = text.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
  const transactions = [];
  for(const line of lines){
    const m = line.match(/^\s*([^:]+)\s*:\s*(.+)$/);
    if(!m) continue;
    const tid = m[1].trim();
    // accepte A B C, ou 1 2 3, ou mixte ‚Äî s√©par√©s par espaces/virgules
    const items = m[2]
      .trim()
      .split(/[,\s]+/)
      .map(tok => tok.replace(/[^\w-]/g,'').toUpperCase()) // ‚Äúa‚Äù‚Üí‚ÄúA‚Äù, enl√®ve ponctuation
      .filter(Boolean);
    // unique + tri naturel (nombres ou lettres)
    const uniq = arr => [...new Set(arr)];
    transactions.push({tid, items: uniq(items).sort(bySym)});
  }
  const all = [...new Set(transactions.flatMap(t=>t.items))].sort(bySym);
  return {transactions, items: all};
}
  function combinations(items){
    const res = [[]];
    for(const x of items){
      const copy = res.map(s => s.concat(x));
      res.push(...copy);
    }
    return res.sort((a,b)=> a.length-b.length || a.join(',').localeCompare(b.join(',')));
  }

  function key(arr){ return arr.join('-'); }
  function label(arr){ return arr.length?`{${arr.join(' ')}}`:'‚àÖ'; }

  let adjacency = new Map();

  function edgesFromSets(sets) {
    const edges = [];
    adjacency = new Map();
    for (const s of sets) {
      adjacency.set(key(s), { parents: new Set(), children: new Set(), set:s });
    }
    for (const s of sets) {
      for (const t of sets) {
        if (t.length === s.length + 1) {
          const isSubset = s.every(e => t.includes(e));
          if (isSubset) {
            edges.push([key(s), key(t)]);
            adjacency.get(key(s)).children.add(key(t));
            adjacency.get(key(t)).parents.add(key(s));
          }
        }
      }
    }
    return edges;
  }

  function layoutSets(sets, width=1400, height=900, top=60, bottom=40){
    const byLevel = new Map();
    let maxLevel = 0;
    for(const s of sets){
      const k = s.length;
      maxLevel = Math.max(maxLevel, k);
      if(!byLevel.has(k)) byLevel.set(k, []);
      byLevel.get(k).push(s);
    }
    const innerH = height - top - bottom;
    const stepY = (innerH / (maxLevel||1)) * 1.3;
    const pos = new Map();
    for(let k=0;k<=maxLevel;k++){
      const row = byLevel.get(k) || [];
      const n = row.length || 1;
      const stepX = width / (n+1);
      row.forEach((set, i)=>{
        const x = stepX*(i+1);
        const y = top + (maxLevel? k*stepY : innerH/2);
        pos.set(key(set), {x,y, level:k, set});
      });
    }
    return {pos, maxLevel};
  }

  const svg = document.getElementById('svg');
  function clearSVG(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }

  function renderLattice(sets){
    clearSVG();
    const width = 1400, height = 900;
    const {pos, maxLevel} = layoutSets(sets, width, height);
    const edges = edgesFromSets(sets);

    // edges
    for(const [fromK,toK] of edges){
      const a = pos.get(fromK), b = pos.get(toK);
      const line = document.createElementNS('http://www.w3.org/2000/svg','line');
      line.setAttribute('x1', a.x);
      line.setAttribute('y1', a.y);
      line.setAttribute('x2', b.x);
      line.setAttribute('y2', b.y);
      line.setAttribute('data-from', fromK);
      line.setAttribute('data-to', toK);
      line.setAttribute('class','edge');
      line.setAttribute('data-from', fromK);
      line.setAttribute('data-to', toK);
      svg.appendChild(line);
    }

    // nodes
    for(const s of sets){
      const p = pos.get(key(s));
      const g = document.createElementNS('http://www.w3.org/2000/svg','g');
      g.setAttribute('class', `node lvl-${p.level}`);
      g.setAttribute('data-key', key(p.set));
      g.setAttribute('transform', `translate(${p.x},${p.y})`);
      const r = Math.max(12, 18 - p.level*1.2);
      const c = document.createElementNS('http://www.w3.org/2000/svg','circle');
      c.setAttribute('r', r);
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.textContent = label(p.set);
      t.setAttribute('style','fill:#eaf2ff;font-size:15px;font-weight:600;font-family:ui-monospace,monospace;dominant-baseline:middle;text-anchor:middle;pointer-events:none;');
      g.appendChild(c); g.appendChild(t);

      // hover
      g.addEventListener('mouseenter', ()=>{
        for(const ln of svg.querySelectorAll('line.edge')){
          ln.classList.remove('hover');
          const [x1,y1,x2,y2] = ['x1','y1','x2','y2'].map(a=>+ln.getAttribute(a));
          if((Math.abs(x1-p.x)<0.5 && Math.abs(y1-p.y)<0.5) || (Math.abs(x2-p.x)<0.5 && Math.abs(y2-p.y)<0.5))
            ln.classList.add('hover');
        }
        c.setAttribute('r', r*1.3);
      });
      g.addEventListener('mouseleave', ()=>{
        for(const ln of svg.querySelectorAll('line.edge')) ln.classList.remove('hover');
        c.setAttribute('r', r);
      });

      // click selection intelligente
      g.addEventListener('click', e=>{
        e.stopPropagation();
        clearSelection();
        highlightByCommonElements(p.set);
      });

      svg.appendChild(g);
    }

    fitViewBox(svg);
  }

  function fitViewBox(svg) {
    const bbox = svg.getBBox();
    svg.setAttribute("viewBox", [
      bbox.x - 100, bbox.y - 100, bbox.width + 200, bbox.height + 200
    ].join(" "));
    viewBox = {x:bbox.x-100,y:bbox.y-100,w:bbox.width+200,h:bbox.height+200};
  }

  // zoom & pan
  let isPanning=false,start={x:0,y:0},viewBox={x:0,y:0,w:1400,h:900};
  svg.addEventListener('mousedown', e=>{isPanning=true;start={x:e.clientX,y:e.clientY};});
  svg.addEventListener('mouseup', ()=>isPanning=false);
  svg.addEventListener('mouseleave', ()=>isPanning=false);
  svg.addEventListener('mousemove', e=>{
    if(!isPanning)return;
    const dx=(e.clientX-start.x)*(viewBox.w/svg.clientWidth);
    const dy=(e.clientY-start.y)*(viewBox.h/svg.clientHeight);
    viewBox.x-=dx; viewBox.y-=dy;
    svg.setAttribute('viewBox',`${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
    start={x:e.clientX,y:e.clientY};
  });
  svg.addEventListener('wheel', e=>{
    e.preventDefault();
    const scale=e.deltaY>0?1.1:0.9;
    viewBox.w*=scale; viewBox.h*=scale;
    svg.setAttribute('viewBox',`${viewBox.x} ${viewBox.y} ${viewBox.w} ${viewBox.h}`);
  });
  svg.addEventListener('click', clearSelection);

  function clearSelection(){
    for(const n of svg.querySelectorAll('.node')) n.classList.remove('selected');
    for(const e of svg.querySelectorAll('.edge')) e.classList.remove('selected');
  }

  // üî∂ nouvelle logique de s√©lection intelligente
function highlightByCommonElements(selectedSet){
  const currentKey = key(selectedSet);
  const selectedKeys = new Set([currentKey]);
  const parentKeys = new Set();
  const childKeys = new Set();

  const currentInfo = adjacency.get(currentKey);
  if (!currentInfo) return;

  // --- 1Ô∏è‚É£ Ajouter r√©cursivement tous les parents (jusqu'√† la racine) ---
  function addParentsRecursively(k){
    const info = adjacency.get(k);
    if(!info) return;
    for(const parent of info.parents){
      if(!selectedKeys.has(parent)){
        selectedKeys.add(parent);
        parentKeys.add(parent);
        addParentsRecursively(parent); // monte r√©cursivement
      }
    }
  }
  addParentsRecursively(currentKey);

  // --- 2Ô∏è‚É£ Ajouter r√©cursivement tous les enfants (descendants) ---
  function addChildrenRecursively(k){
    const info = adjacency.get(k);
    if(!info) return;
    for(const child of info.children){
      if(!selectedKeys.has(child)){
        selectedKeys.add(child);
        childKeys.add(child);
        addChildrenRecursively(child); // descend r√©cursivement
      }
    }
  }
  addChildrenRecursively(currentKey);

  // --- 3Ô∏è‚É£ R√©initialiser styles ---
  for(const n of svg.querySelectorAll('.node')) n.classList.remove('selected','parent','child');
  for(const e of svg.querySelectorAll('.edge')) e.classList.remove('selected','parent-edge','child-edge');

  // --- 4Ô∏è‚É£ Surligner les n≈ìuds ---
  for(const k of selectedKeys){
    const g = svg.querySelector(`.node[data-key="${k}"]`);
    if(!g) continue;
    if(k === currentKey){
      g.classList.add('selected'); // n≈ìud principal
    } else if(parentKeys.has(k)){
      g.classList.add('parent');
    } else if(childKeys.has(k)){
      g.classList.add('child');
    }
  }

  // --- 5Ô∏è‚É£ Surligner les ar√™tes ---
  for(const e of svg.querySelectorAll('.edge')){
    const f = e.getAttribute('data-from'), t = e.getAttribute('data-to');
    if(selectedKeys.has(f) && selectedKeys.has(t)){
      if(parentKeys.has(f) && selectedKeys.has(t))
        e.classList.add('parent-edge');
      else if(childKeys.has(t) && selectedKeys.has(f))
        e.classList.add('child-edge');
      else
        e.classList.add('selected');
    }
  }
}

  // renvoie tous les sous-ensembles de taille 1 et 2
  function getSubsets(set){
    const res=[];
    for(let i=0;i<set.length;i++) res.push([set[i]]);
    for(let i=0;i<set.length;i++)
      for(let j=i+1;j<set.length;j++)
        res.push([set[i],set[j]]);
    return res;
  }

  const datasetEl=document.getElementById('dataset');
  document.getElementById('btnSample')?.addEventListener('click', ()=>{
    datasetEl.value=`100: 1 3 4
200: 2 3 5
300: 1 2 3 5
400: 2 5`;
    build();
  });
  document.getElementById('btnBuild')?.addEventListener('click', build);

  function build(){
    const {items}=parseDataset(datasetEl.value);
    if(items.length===0){alert('Dataset invalide');return;}
    const sets=combinations(items);
    renderLattice(sets);
    renderItems(items);
  }
function renderItems(items){
  const wrap = document.getElementById('items');
  wrap.innerHTML = '';

  // üü¶ Affichage des items d√©tect√©s
  const title = document.createElement('h4');
  title.textContent = 'Items d√©tect√©s :';
  title.style.marginBottom = '8px';
  wrap.appendChild(title);

  const list = document.createElement('div');
  list.style.display = 'flex';
  list.style.flexWrap = 'wrap';
  list.style.gap = '8px';
  for (const it of items) {
    const el = document.createElement('div');
    el.className = 'tag';
    el.textContent = `{${it}}`;
    el.style.padding = '4px 8px';
    el.style.background = '#1a2b4c';
    el.style.borderRadius = '6px';
    el.style.color = '#eaf2ff';
    el.style.fontWeight = '600';
    list.appendChild(el);
  }
  wrap.appendChild(list);

  // üß† Calcul du nombre total d‚Äôitemsets
  const d = items.length;
  const total = Math.pow(2, d) - 1;

  const formula = document.createElement('div');
  formula.style.marginTop = '12px';
  formula.style.fontSize = '14px';
  formula.style.color = '#9fb8ff';
  formula.innerHTML = `
    <hr style="border:0;border-top:1px solid #223;">
    <div><b>d</b> = ${d} items distincts</div>
    <div style="margin-top:4px;">
      <b>Nombre total d‚Äôitemsets</b> = <br> 
      Œ£<sub>k=1</sub><sup>${d}</sup> C(${d},k) = 2<sup>${d}</sup> ‚àí 1 = 
      <span style="color:#ffb347;font-weight:600;">${total}  <br> </span>
      <span style="color:#ffb347;font-weight:600;">Sans compter l'ensemble vide car On a -1 </span>
    </div>
  `;
  wrap.appendChild(formula);
}


let dernierItemsetFrequent = null;
document.getElementById('btnSupport')?.addEventListener('click', calculerSupport);
// üîπ remplace l'ancienne variable dernierItemsetFrequent
let dernierNiveauFrequent = []; // [{itemset: [...], sup: n}, ...]
let kMax = 0;                   // taille des itemsets de Lk final
function calculerSupport() {
  console.log("---- D√©but calculerSupport ----");

  const minSup = parseInt(document.getElementById('minSupport').value);
  const { transactions, items } = parseDataset(datasetEl.value);
  const allSets = combinations(items).filter(s => s.length > 0);

  const container = document.getElementById('apriori-steps');
  container.innerHTML = '';

  // üîπ Reset visuel
  for (const n of svg.querySelectorAll('.node')) n.classList.remove('invalid','valid');
  for (const e of svg.querySelectorAll('.edge')) e.classList.remove('invalid-edge');

  let step = 1;
  let Ck = allSets.filter(s => s.length === step);
  let Lk = [];
  let dernierValide = []; // ‚úÖ garde le dernier niveau fr√©quent non vide

  while (Ck.length > 0) {
    const color = stepColors[(step - 1) % stepColors.length];

    // üîπ Calcul des supports
    const supports = Ck.map(s => ({
      itemset: s,
      sup: transactions.filter(t => s.every(x => t.items.includes(x))).length
    }));

    // --- Afficher Ck ---
    container.appendChild(renderTableWithStepColor(`C${step}`, supports, minSup, color));

    const valid = supports.filter(o => o.sup >= minSup);
    const invalid = supports.filter(o => o.sup < minSup);

    highlightSetsStepColor(invalid, color);

    // --- Afficher Lk ---
    if (valid.length > 0) {
      container.appendChild(renderTableWithStepColor(`L${step}`, valid, minSup, color, true));
      dernierValide = valid; // ‚úÖ sauvegarde le dernier Lk non vide
    }

    // üîπ Pr√©pare C(k+1)
    const nextItems = uniq(valid.flatMap(o => o.itemset));
    const next = combinations(nextItems).filter(s => s.length === step + 1);

    if (next.length === 0) break; // ‚úÖ stop si plus de combinaisons

    Ck = next;
    Lk = valid;
    step++;
  }

  // üîπ R√©sum√© final
  if (dernierValide.length > 0) {
    dernierNiveauFrequent = dernierValide.slice();
    kMax = dernierValide[0].itemset.length;

    const totalTrans = transactions.length;
    const summaryLines = dernierValide.map(o => {
      const supportAbsolu = o.sup;
      const supportRelatif = (o.sup / totalTrans).toFixed(2);
      return `<div>‚Ä¢ {${o.itemset.join(' ')}} ‚Üí sup = ${supportAbsolu} (${supportRelatif})</div>`;
    }).join('');

    const chips = dernierValide.map(o => `{${o.itemset.join(' ')}}`).join(', ');
    const summaryDiv = document.createElement('div');
    summaryDiv.id = 'final-summary';
    summaryDiv.innerHTML = `
      <h3>üß© R√©sultat final Apriori</h3>
      <p><b>L<sub>${kMax}</sub> fr√©quent (${dernierValide.length} itemset${dernierValide.length>1?'s':''}) :</b> ${chips}</p>
      <div style="margin-top:8px; font-size:14px; color:#9fb8ff;">${summaryLines}</div>
      <p style="margin-top:10px;">üìä <b>Total transactions :</b> ${totalTrans}</p>
    `;
    document.getElementById('apriori-steps').appendChild(summaryDiv);

    console.log("‚úÖ Dernier niveau fr√©quent :", dernierNiveauFrequent);
    console.log("‚úÖ Taille du dernier niveau (kMax) :", kMax);
  } else {
    dernierNiveauFrequent = [];
    kMax = 0;
    console.warn("‚ö†Ô∏è Aucun niveau fr√©quent trouv√© (Lk vide). Lance d'abord le calcul du support (Apriori).");

    const warnDiv = document.createElement('div');
    warnDiv.id = 'final-summary';
    warnDiv.style.background = '#3b1a1a';
    warnDiv.style.color = '#ffaaaa';
    warnDiv.style.padding = '10px';
    warnDiv.style.borderRadius = '6px';
    warnDiv.innerHTML = `
      ‚ö†Ô∏è <b>Aucun dernier niveau fr√©quent</b>.<br>
      Lance d‚Äôabord le calcul du support (Apriori).
    `;
    document.getElementById('apriori-steps').appendChild(warnDiv);
  }
}
console.log("Dernier itemset fr√©quent :", dernierItemsetFrequent);
console.log("Dernier itemset global :", dernierItemsetFrequent);
const stepColors = [
  '#ffb703', // jaune
  '#7b61ff', // violet
  '#e91e63', // rose
  '#00bcd4', // cyan
  '#8bc34a', // vert
  '#ff9800', // orange
  '#9c27b0'  // mauve
];


function renderTableWithStepColor(label, data, minSup, color, highlight=false) {
  const table = document.createElement('table');
  const title = document.createElement('h4');
  title.innerHTML = `${label}`;
  title.style.color = color;
  table.innerHTML = `
    <tr><th>itemset</th><th>sup.</th></tr>
    ${data.map(d=>`<tr style="background:${d.sup < minSup ? color+'33' : '#1c3f28'};">
      <td>{${d.itemset.join(' ')}}</td>
      <td>${d.sup}</td>
    </tr>`).join('')}
  `;
  const wrapper = document.createElement('div');
  wrapper.appendChild(title);
  wrapper.appendChild(table);
  return wrapper;
}

function highlightSetsStepColor(list, color){
  for(const o of list){
    const k = key(o.itemset);
    colorNodeAndDescendants(k, color);
  }
}

function colorNodeAndDescendants(k, color){
  const g = svg.querySelector(`.node[data-key="${k}"]`);
  if(g){
    const c = g.querySelector('circle');
    if(c){
      c.style.stroke = color;
      c.style.strokeWidth = '3px';
      c.style.filter = `drop-shadow(0 0 5px ${color}aa)`;
      c.style.opacity = 0.9;
    }
  }
  const info = adjacency.get(k);
  if(!info) return;
  for(const child of info.children){
    colorNodeAndDescendants(child, color);
  }
}



function highlightSetsStepColor(list, color){
  for(const o of list){
    const k = key(o.itemset);
    colorNodeAndDescendants(k, color);
  }
}

function colorNodeAndDescendants(k, color){
  const g = svg.querySelector(`.node[data-key="${k}"]`);
  if(g){
    const c = g.querySelector('circle');
    if(c){
      c.style.stroke = color;
      c.style.strokeWidth = '3px';
      c.style.filter = `drop-shadow(0 0 5px ${color}aa)`;
      c.style.opacity = 0.9;
    }
  }

  // üîπ Colorer les ar√™tes sortantes
  for (const e of svg.querySelectorAll('.edge')) {
    const f = e.getAttribute('data-from');
    const t = e.getAttribute('data-to');
    if (f === k) {
      e.style.stroke = color;
      e.style.strokeWidth = '2.2px';
      e.style.opacity = 0.8;
      e.style.filter = `drop-shadow(0 0 3px ${color}88)`;
    }
  }

  // üîπ Descendants r√©cursifs
  const info = adjacency.get(k);
  if(!info) return;
  for(const child of info.children){
    colorNodeAndDescendants(child, color);
  }
}
function calculerRegles() {
  const { transactions } = parseDataset(datasetEl.value);
  const minSup = parseInt(document.getElementById('minSupport').value, 10) || 2;

  if (!dernierNiveauFrequent.length) {
    alert("‚ö†Ô∏è Aucun dernier niveau fr√©quent. Lance d'abord le calcul du support (Apriori).");
    return;
  }

  const d = kMax;                                   // d = taille du dernier niveau
  const R = Math.pow(3, d) - Math.pow(2, d + 1) + 1;

  // üîπ G√©n√©rer des r√®gles pour CHAQUE itemset du dernier Lk
  const rules = [];
  for (const { itemset, sup } of dernierNiveauFrequent) {
    const subsets = allNonEmptyProperSubsets(itemset);   // tous X non vides et ‚â† itemset
    const supXY = sup / transactions.length;             // support du set complet (X‚à™Y = itemset)

    for (const X of subsets) {
      const Y = itemset.filter(v => !X.includes(v));
      if (Y.length === 0) continue;

      const supX = transactions.filter(t => X.every(x => t.items.includes(x))).length / transactions.length;
      const supY = transactions.filter(t => Y.every(y => t.items.includes(y))).length / transactions.length;

      const conf = supXY / supX;
      const lift = conf / supY; // am√©lioration

      rules.push({
        source: itemset.join(' '),        // pour savoir de quel Lk vient la r√®gle
        X, Y,
        support: supXY.toFixed(2),
        confiance: conf.toFixed(2),
        freqY: supY.toFixed(2),
        amelioration: lift.toFixed(2)
      });
    }
  }

  // meilleure r√®gle (optionnel)
  const best = rules.reduce((a,b)=> (+b.amelioration > +a.amelioration ? b : a), rules[0]);

  // --- R√©sum√©
  const chips = dernierNiveauFrequent.map(o => `{${o.itemset.join(' ')}}`).join(' , ');
  const summary = `
    <h3>üß† R√®gles d‚Äôassociation</h3>
    <p><b>d = ${d}</b> ‚Üí taille du dernier itemset fr√©quent.</p>
    <p><b>R = 3<sup>${d}</sup> - 2<sup>${d+1}</sup> + 1 = ${R}</b> r√®gles possibles (th√©orique pour d).</p>
    <p><b>L<sub>${d}</sub> fr√©quent :</b> ${chips}</p>
    <p><b>Min Support :</b> ${minSup}</p>
    <p><b>R√®gles g√©n√©r√©es :</b> ${rules.length}</p>
  `;
  document.getElementById('rules-summary').innerHTML = summary;

  // --- Tableau
  const tableHTML = `
    <table>
      <tr>
        <th>#</th>
        <th>Itemset source (L${d})</th>
        <th>R√®gle</th>
        <th>Support (s)</th>
        <th>Confiance (Œ±)</th>
        <th>Fr√©q(Y)</th>
        <th>Am√©lioration</th>
      </tr>
      ${rules.map((r,i)=>`
        <tr ${r===best ? 'style="background:#1b2e1a;color:#b5ffb5;font-weight:600;"':''}>
          <td>${i+1}</td>
          <td>{${r.source}}</td>
          <td>{${r.X.join(' ')}} ‚áí {${r.Y.join(' ')}}</td>
          <td>${r.support}</td>
          <td>${r.confiance}</td>
          <td>${r.freqY}</td>
          <td>${r.amelioration}</td>
        </tr>
      `).join('')}
    </table>
  `;
  document.getElementById('rules-table').innerHTML = tableHTML;
}
function allNonEmptyProperSubsets(arr) {
  const res = [];
  const n = arr.length;
  for (let i = 1; i < (1 << n) - 1; i++) {
    const subset = [];
    for (let j = 0; j < n; j++) {
      if (i & (1 << j)) subset.push(arr[j]);
    }
    res.push(subset);
  }
  return res;
}
build();
</script>
</body>
</html>